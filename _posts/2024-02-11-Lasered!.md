---
title: "Lasered!: Laser Cutting Designs"
layout: post
---
This project showcases my first effort in creating computational designs, and fabricating them with a laser cutter/engraver. I first took three inspirations: the solar system, topographic map designs, and spiral designs. From there I studied the math and computation behind how these patterns show up in the real world and used that to create closely related and generated designs using Processing 4. To finish it all off I used Rhino and a laser cutter/engraver to make these designs a reality by engraving and cutting them out on pieces of plywood. This blog details my process, and the results of my work.

# Materials Used
### Software & Machines
- **Processing 4:** Used to generate the computational designs.
- **Rhino Software:** Utilized for refining designs and for preparing files for laser cutting.

- **Laser Engraver:** Employed laser cutter from BTU (Blow Things Up) Lab at the University of Colorado Boulder to fabricate generated designs.

### Physical Materials
- **Handprint 1/4" x 12" x 12" Birch Plywood:** Chosen for its durability and suitability for laser cutting. Provides an aesthetically pleasing base for designs.

# Design 1: Topographic Map Design

### Procedure

### Mathematical Calculations

### Output
<img src="../assets/topographicOutput.svg" alt="Topographic Map Generated in Processing" width="350" height="250">
<img src="../assets/topographicFabricated.jpg" alt="Topographic Map Design Fabricated" width="350" height="250">

### Code

<div>
<script src="https://gist.github.com/Wian9699/993a14eee934154baa5375f3ec76d730.js"></script>
</div>
<div style = "font-size: 12px;"> 

```
    //Tells how many different elevation levels I want
    int numLevels = 20;

    //Determines if we want to zoom in or out of the noise field
    float noiseScale = .001;

    //Determines how many coordinate points we will observe
    //less means we will observe more = more detail
    //more means we observe less = less detail
    int detail = 8;

    void setup() {
        size(800, 800);
        background(255);
        noLoop();
    
    }

    void draw() {
    
        stroke(0);
        strokeWeight(5);
        noFill();
        
        //Will run through each elevation level from 1 to numLevels
        for (float level = 1; level <= numLevels; level++) {

            // Maps values from one range to another range. for example, takes the range of
            //   1 to numLevels and converts it to a range from 0 to 1.
            // In the context of this, we want to map the elevation levels in a range from 0 to 1
            //   because noise with return values from 0 to 1. 
            float threshold = map(level, 1, numLevels, 0, 1); 

            //Iterates through each coordinate on the window. Will skip coordinated depending
            //   on the level of detail desired
            for (int x = 0; x < width; x+= detail) {
                for (int y = 0; y < height; y+= detail) {

                    // Will go and retreive noise value for certain coordinate determining its
                    //   elevation
                    float elevation = noise(x * noiseScale, y * noiseScale);

                    //If the elevation at the coordinate and the elevation at the level we
                    //   are currently checking for are similar enough, we plot a circle on 
                    //   the window
                    if (abs(elevation - threshold) < 0.01) {
                    ellipse(x, y, 2, 2);
                    }
                }
            }
        }
    }
```
</div>

# Design 2: Generated Solar System

### Procedure

### Mathematical Calculations

### Output
<img src="../assets/solarSystemOutput.svg" alt="Solar System Generated in Processing" width="350" height="250">
<img src="../assets/solarSystemFabricated.jpg" alt="Solar System Design Fabricated" width="350" height="250">

### Code
<div style = "font-size: 12px;"> 

```
int sunX, sunY, numPlanets;
float[] orbitRadius, eccentricity, angle, planetSize, orbitRotation;

void setup() {
  size(800, 800);
  sunX = width / 2;
  sunY = height / 2;
  noLoop(); 
  
  numPlanets = int(random(3, 5)); // random number of planets
  orbitRadius = new float[numPlanets];
  eccentricity = new float[numPlanets];
  angle = new float[numPlanets];
  planetSize = new float[numPlanets];
  orbitRotation = new float[numPlanets]; 
  
  float minOrbitRadius = 100; 
  float maxOrbitRadius = width / 2 - 50;
  float orbitSpacing = (maxOrbitRadius - minOrbitRadius + 50) / numPlanets;
  
  // Will go through each planet and initialize with variables
  for (int i = 0; i < numPlanets; i++) {
    orbitRadius[i] = minOrbitRadius + i * orbitSpacing; // Spaced orbit radius
    eccentricity[i] = random(0.0, 0.7); // Random eccentricity of orbit
    angle[i] = random(TWO_PI); // Random starting angle on orbit for planets
    planetSize[i] = random(20,60); // Random planet size
    orbitRotation[i] = random(TWO_PI); // Random orbit rotation
  }
}

void draw() {
  background(255);

  // Calls function to draw sun
  drawSun(sunX, sunY, 20); // coordinates, and radius

  // Goes through each planet and from center and draws planets and orbits
  for (int i = 0; i < numPlanets; i++) {
    //saves current transform matrix
    pushMatrix();
    //sets point of reference at center of window
    translate(sunX, sunY);
    //gives the planet its random orbit rotation
    rotate(orbitRotation[i]);
    drawOrbit(orbitRadius[i], eccentricity[i]); // draws orbit
    //draws planet
    drawPlanet(orbitRadius[i], eccentricity[i], angle[i], planetSize[i]);
    //returns to original state
    popMatrix();
  }
}

void drawSun(float x, float y, float radius) {
  
  float spikeLength = 15; // spike length on sun
  int numSpikes = 12; // number of spikes on sun

  // Angle between each spike
  float angleStep = TWO_PI / numSpikes;

  beginShape(); //being drawing shape
  // once angle reaches two pi, it no longer needs to draw shape
  for (float angle = 0; angle < TWO_PI; angle += angleStep) {
    // Point on the circle
    float outerX = x + cos(angle) * (radius + spikeLength);
    float outerY = y + sin(angle) * (radius + spikeLength);
    vertex(outerX, outerY);

    // Point between the spikes
    if (angle + angleStep < TWO_PI) {
      float innerX = x + cos(angle + angleStep / 2) * radius;
      float innerY = y + sin(angle + angleStep / 2) * radius;
      vertex(innerX, innerY);
    }
  }
  endShape();
}

void drawOrbit(float radius, float ecc) {
  noFill();
  strokeWeight(1);

  // Calculate semi-major and semi-minor axes
  float semiMajorAxis = radius * (1 + ecc);
  float semiMinorAxis = radius * (1 - ecc);

  // Draw ellipse with width and height being the semiMajor and semiMinor Axis
  //   multiplied by two to get full width and height of ellipse
  ellipse(0, 0, 2 * semiMajorAxis, 2 * semiMinorAxis);

  strokeWeight(1); // Resetting stroke weight for other elements
}



void drawPlanet(float radius, float ecc, float ang, float size) {
  
  //calculate semiMajor and semiMinor Axis
  float semiMajorAxis = radius * (1 + ecc);
  float semiMinorAxis = radius * (1 - ecc);
  
  // using random angle assigned to each planet, calculates point on orbit
  //   to draw planet
  float x = semiMajorAxis * cos(ang);
  float y = semiMinorAxis * sin(ang);
  fill(255);
  // draws ellipse with random size, and coordinate along orbit
  ellipse(x, y, size, size);
}
```
</div>

# Design 3: Spiral of Triangles: 

### Procedure

### Mathematical Calculations

### Output
<img src="../assets/spiralOutput.png" alt="Spiral Generated in Processing" width="300" height="250">

### Code
<div style = "font-size: 12px;">

```

float angle = 0;
float radius = 0;
int maxTriangles = 1000; 

void setup() {
  size(800, 800);
  background(255);
  noLoop(); 
}

void draw() {
    translate(width/2, height/2); 

    for (int i = 0; i < maxTriangles; i++) {
    float x1 = radius * cos(angle);
    float y1 = radius * sin(angle);

    float x2 = x1 + 30 * cos(angle - PI/6);
    float y2 = y1 + 30 * sin(angle - PI/6);
    float x3 = x1 + 30 * cos(angle + PI/6);
    float y3 = y1 + 30 * sin(angle + PI/6);

    triangle(x1, y1, x2, y2, x3, y3);

    angle += 0.4;
    radius += .3;
  }
}
```
</div>

# Challenges Faced

# Conclusion

# Work Cited
